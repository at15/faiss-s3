---
tags:
  - rust
  - cpp
  - faiss
  - tantivy
  - filter
---

# 02 Tantivy with local Faiss

Take step back for Faiss, just combine faiss with tantivy using local files.

## Background

Previously we tested filter using faiss and tantivy using python bindings.
But we had a few issues:

- `search_preassigned` is not supported in python bindings
- within a cluster, we still need to use the tantivy search result as id selector

Things we need to do

- Add tantivy
- Generate embedding in rust
  - https://github.com/huggingface/candle/tree/main/candle-examples/examples/clip
  - https://github.com/EricLBuehler/mistral.rs uses candle but comes with many models
  - https://github.com/EricLBuehler/mistral.rs/blob/master/mistralrs/examples/qwen3_embedding/main.rs
  - https://github.com/huggingface/text-embeddings-inference a server with text embedding support
  - https://github.com/Anush008/fastembed-rs using ONNX and supports sentence transformer models

Tried `mistral.rs` it works

- `all-MiniLM-L6-v2` used by SentenceTransformer does not work because BERT model is not supported
- `google/embeddinggemma-300m` works, but requires HF auth
   - btw: load model took a while, even in rust ...

Let's start with text embedding and see if it works with faiss.

- We need to pass raw pointers to faiss for training
- Come up with a dataset, we can probably try the same hardcoded tennis dataset for now
- Write the design for filter using tantivy

## Build faiss index using vectors from rust

The interface from faiss is the following:

- a `const float*` pointer to the vectors
- a `idx_t` for the number of vectors

```cpp
void IndexIVF::train(idx_t n, const float* x);
void IndexIVF::add(idx_t n, const float* x);
```

The dimension of vectors are defined when creating the index and quantizer.

- `google/embeddinggemma-300m` generates 768 dimension with float32 by default

```cpp
const size_t VEC_DIM = 128;       // Vector dimension
const size_t N_CLUSTERS = 100;    // Number of IVF clusters

// Create index, default invert list implementation is memory
faiss::IndexFlatL2 quantizer(VEC_DIM);
faiss::IndexIVFFlat index(&quantizer, VEC_DIM, N_CLUSTERS);
```

The return type for embedding generated by mistral.rs is `Vec<Vec<f32>>`.

Now we need a method to pass

- name of the vector file
- dimension of vectors
- number of vectors
- vectors

We need to flatten `Vec<Vec<f32>>` to `const float*`

The interface that we got working is

- pass a rust `Vec<float>` to C++
- use `data.data()` to get the raw pointer

```cpp
void CreateExampleIVFIndexWithData(rust::Str index_file_name, size_t dim,
                                   size_t n_vectors, rust::Vec<float> data,
                                   size_t n_clusters) {
  index.train(N_VECTORS, data.data());
  index.add(N_VECTORS, data.data());
}
```

```rust
// lib.rs
fn CreateExampleIVFIndexWithData(
    index_file_name: &str,
    dim: usize,
    n_vectors: usize,
    data: Vec<f32>,
    n_clusters: usize,
);
```

## Build Tantivy index in rust

Copied some code from claude code, it compiles, what we really need are:

Let's use book as an example, we can use https://amazon-reviews-2023.github.io/ the amazon reviews dataset

We need to explore it using python scripts first to know what we are doing

```bash
pip install marimo
```

Use [amazon-reviews-converter.py](../amazon-reviews-converter.py) to convert the dataset to a csv file

```text
============================================================
DATA ANALYSIS WITH POLARS
============================================================

Total records: 89251

DataFrame shape: (89251, 7)

------------------------------------------------------------
UNIQUE MAIN CATEGORIES
------------------------------------------------------------
shape: (9, 2)
┌──────────────────────┬───────┐
│ main_category        ┆ count │
│ ---                  ┆ ---   │
│ str                  ┆ u32   │
╞══════════════════════╪═══════╡
│ Appstore for Android ┆ 68679 │
│ Software             ┆ 18791 │
│ null                 ┆ 1769  │
│ Gift Cards           ┆ 4     │
│ Home Audio & Theater ┆ 2     │
│ Books                ┆ 2     │
│ Computers            ┆ 2     │
│ AMAZON FASHION       ┆ 1     │
│ Toys & Games         ┆ 1     │
└──────────────────────┴───────┘

------------------------------------------------------------
CATEGORIES ANALYSIS
------------------------------------------------------------
Records with categories: 18791
Records without categories (null): 70460
Records without categories (empty string): 0

Top 20 individual categories:
shape: (20, 2)
┌──────────────────────────────┬───────┐
│ category_list                ┆ count │
│ ---                          ┆ ---   │
│ str                          ┆ u32   │
╞══════════════════════════════╪═══════╡
│ Software                     ┆ 18791 │
│ Education & Reference        ┆ 2716  │
│ Business & Office            ┆ 2322  │
│ Lifestyle & Hobbies          ┆ 1624  │
│ Photography & Graphic Design ┆ 1452  │
│ …                            ┆ …     │
│ All Microsoft                ┆ 621   │
│ Photography                  ┆ 613   │
│ Antivirus                    ┆ 590   │
│ Music                        ┆ 578   │
│ Internet Security Suites     ┆ 574   │
└──────────────────────────────┴───────┘

------------------------------------------------------------
AVERAGE RATING DISTRIBUTION
------------------------------------------------------------
shape: (1, 5)
┌──────────┬────────┬──────────┬─────┬─────┐
│ mean     ┆ median ┆ std      ┆ min ┆ max │
│ ---      ┆ ---    ┆ ---      ┆ --- ┆ --- │
│ f64      ┆ f64    ┆ f64      ┆ f64 ┆ f64 │
╞══════════╪════════╪══════════╪═════╪═════╡
│ 3.354704 ┆ 3.4    ┆ 0.815439 ┆ 0.0 ┆ 5.0 │
└──────────┴────────┴──────────┴─────┴─────┘

Rating distribution (binned):
shape: (5, 2)
┌────────────┬───────┐
│ rating_bin ┆ count │
│ ---        ┆ ---   │
│ cat        ┆ u32   │
╞════════════╪═══════╡
│ 0-1        ┆ 3125  │
│ 1-2        ┆ 3202  │
│ 2-3        ┆ 20441 │
│ 3-4        ┆ 49294 │
│ 4-5        ┆ 13189 │
└────────────┴───────┘

------------------------------------------------------------
RATING NUMBER DISTRIBUTION
------------------------------------------------------------
shape: (1, 5)
┌────────────┬────────┬──────────────┬─────┬─────────┐
│ mean       ┆ median ┆ std          ┆ min ┆ max     │
│ ---        ┆ ---    ┆ ---          ┆ --- ┆ ---     │
│ f64        ┆ f64    ┆ f64          ┆ i64 ┆ i64     │
╞════════════╪════════╪══════════════╪═════╪═════════╡
│ 606.175875 ┆ 11.0   ┆ 11594.907341 ┆ 0   ┆ 1898759 │
└────────────┴────────┴──────────────┴─────┴─────────┘

Rating number distribution:
  Zero ratings: 2959
  1-10 ratings: 40339
  11-100 ratings: 30512
  101-1000 ratings: 12083
  1000+ ratings: 3358

------------------------------------------------------------
PRICE DISTRIBUTION
------------------------------------------------------------
shape: (1, 5)
┌──────────┬────────┬───────────┬─────┬────────┐
│ mean     ┆ median ┆ std       ┆ min ┆ max    │
│ ---      ┆ ---    ┆ ---       ┆ --- ┆ ---    │
│ f64      ┆ f64    ┆ f64       ┆ f64 ┆ f64    │
╞══════════╪════════╪═══════════╪═════╪════════╡
│ 2.351605 ┆ 0.0    ┆ 22.814413 ┆ 0.0 ┆ 1998.0 │
└──────────┴────────┴───────────┴─────┴────────┘

Free apps (price = 0): 73044
Paid apps (price > 0): 16207
```

## Expose id selector in faiss and use index from tantivy

- [x] Can you use id selector for quantizer when using IVF index? Yes, you can pass in the id selector when searching the quantizer
- [ ] Efficient way to pass id selector to faiss?
  - There is builtin `IDSelectorBitmap` and `IDSelectorBatch`

### Search quantizer with id selector

- We use `IndexFlatL2` for quantizer, which supports id selector

```cpp
void CreateExampleIVFIndex(rust::Str index_file_name) {
  std::cout << "Creating example IVF index in " << index_file_name << std::endl;
  const size_t VEC_DIM = 128;      // Vector dimension
  const size_t N_CLUSTERS = 100;   // Number of IVF clusters
  const size_t N_VECTORS = 10'000; // Number of vectors to index

  // Create index, default invert list implementation is memory
  faiss::IndexFlatL2 quantizer(VEC_DIM);
  faiss::IndexIVFFlat index(&quantizer, VEC_DIM, N_CLUSTERS);
```

We can first try to see if we can use id selector ...

```cpp
// IndexFlat.cpp
void IndexFlat::search(
        idx_t n,
        const float* x,
        idx_t k,
        float* distances,
        idx_t* labels,
        const SearchParameters* params) const {
    IDSelector* sel = params ? params->sel : nullptr;
    FAISS_THROW_IF_NOT(k > 0);

    // we see the distances and labels as heaps
    if (metric_type == METRIC_INNER_PRODUCT) {
        float_minheap_array_t res = {size_t(n), size_t(k), labels, distances};
        knn_inner_product(x, get_xb(), d, n, ntotal, &res, sel);
    } else if (metric_type == METRIC_L2) {
        float_maxheap_array_t res = {size_t(n), size_t(k), labels, distances};
        knn_L2sqr(x, get_xb(), d, n, ntotal, &res, nullptr, sel);
    } else {
        FAISS_THROW_IF_NOT(!sel); // TODO implement with selector
        knn_extra_metrics(
                x,
                get_xb(),
                d,
                n,
                ntotal,
                metric_type,
                metric_arg,
                k,
                distances,
                labels);
    }
}
```

Yeah we can pass id selector for quantizer

```cpp
void SearchExampleIVFIndex(rust::Str index_file_name) {
  // 1. Search the quantizer to the clusters
  double t0 = faiss::getmillisecs();
  // Pass id selector to quantizer
  faiss::SearchParameters quantizer_params = faiss::SearchParameters();
  // NOTE: Without this, the clusters are 6, 42
  std::vector<idx_t> ids = {1, 2};
  faiss::IDSelectorArray id_selector =
      faiss::IDSelectorArray(ids.size(), ids.data());
  quantizer_params.sel = &id_selector;
  ivf_index->quantizer->search(n, x.data(), nprobe, coarse_dis.get(), idx.get(),
                               &quantizer_params);
  double t1 = faiss::getmillisecs();
  // We only have one query, so the the first nprobe entries are for one (and only) query
  for (size_t i = 0; i < nprobe; i++) {
    std::cout << "Probe " << i << ", cluster id: " << idx[i]
              << ", distance: " << coarse_dis[i] << std::endl;
  }
}
```

### Pass id selector to faiss

We can use `IDSelectorBatch` it will build the set and bitmap automatically.
Also I think it is more efficient to build a new faiss index in memory
with only the selected vectors base on the result from tantivy.

```cpp
IDSelectorBatch::IDSelectorBatch(size_t n, const idx_t* indices) {
    nbits = 0;
    while (n > ((idx_t)1 << nbits)) {
        nbits++;
    }
    nbits += 5;
    // for n = 1M, nbits = 25 is optimal, see P56659518

    mask = ((idx_t)1 << nbits) - 1;
    bloom.resize((idx_t)1 << (nbits - 3), 0);
    for (idx_t i = 0; i < n; i++) {
        idx_t id = indices[i];
        set.insert(id);
        id &= mask;
        bloom[id >> 3] |= 1 << (id & 7);
    }
}

bool IDSelectorBatch::is_member(idx_t i) const {
    long im = i & mask;
    if (!(bloom[im >> 3] & (1 << (im & 7)))) {
        return 0;
    }
    return set.count(i);
}
```