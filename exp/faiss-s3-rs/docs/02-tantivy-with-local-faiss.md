---
tags:
  - rust
  - cpp
  - faiss
  - tantivy
  - filter
---

# 02 Tantivy with local Faiss

Take step back for Faiss, just combine faiss with tantivy using local files.

## Background

Previously we tested filter using faiss and tantivy using python bindings.
But we had a few issues:

- `search_preassigned` is not supported in python bindings
- within a cluster, we still need to use the tantivy search result as id selector

Things we need to do

- Add tantivy
- Generate embedding in rust
  - https://github.com/huggingface/candle/tree/main/candle-examples/examples/clip
  - https://github.com/EricLBuehler/mistral.rs uses candle but comes with many models
  - https://github.com/EricLBuehler/mistral.rs/blob/master/mistralrs/examples/qwen3_embedding/main.rs
  - https://github.com/huggingface/text-embeddings-inference a server with text embedding support

Tried `mistral.rs` it works

- `all-MiniLM-L6-v2` used by SentenceTransformer does not work because BERT model is not supported
- `google/embeddinggemma-300m` works, but requires HF auth
   - btw: load model took a while, even in rust ...

Let's start with text embedding and see if it works with faiss.

- We need to pass raw pointers to faiss for training
- Come up with a dataset, we can probably try the same hardcoded tennis dataset for now
- Write the design for filter using tantivy

## Build faiss index using vectors from rust

The interface from faiss is the following:

- a `const float*` pointer to the vectors
- a `idx_t` for the number of vectors

```cpp
void IndexIVF::train(idx_t n, const float* x);
void IndexIVF::add(idx_t n, const float* x);
```

The dimension of vectors are defined when creating the index and quantizer.

- `google/embeddinggemma-300m` generates 768 dimension with float32 by default

```cpp
const size_t VEC_DIM = 128;       // Vector dimension
const size_t N_CLUSTERS = 100;    // Number of IVF clusters

// Create index, default invert list implementation is memory
faiss::IndexFlatL2 quantizer(VEC_DIM);
faiss::IndexIVFFlat index(&quantizer, VEC_DIM, N_CLUSTERS);
```

The return type for embedding generated by mistral.rs is `Vec<Vec<f32>>`.

Now we need a method to pass

- name of the vector file
- dimension of vectors
- number of vectors
- vectors

We need to flatten `Vec<Vec<f32>>` to `const float*`

The interface that we got working is

- pass a rust `Vec<float>` to C++
- use `data.data()` to get the raw pointer

```cpp
void CreateExampleIVFIndexWithData(rust::Str index_file_name, size_t dim,
                                   size_t n_vectors, rust::Vec<float> data,
                                   size_t n_clusters) {
  index.train(N_VECTORS, data.data());
  index.add(N_VECTORS, data.data());
}
```

```rust
// lib.rs
fn CreateExampleIVFIndexWithData(
    index_file_name: &str,
    dim: usize,
    n_vectors: usize,
    data: Vec<f32>,
    n_clusters: usize,
);
```

## Build Tantivy index in rust