#include <iostream>
#include <string>
#include <sys/stat.h>

#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFFlat.h>
#include <faiss/impl/FaissAssert.h>
#include <faiss/index_io.h>
#include <faiss/invlists/InvertedListsIOHook.h>
#include <faiss/invlists/OnDiskInvertedLists.h>
#include <faiss/utils/random.h>

#include "faiss_s3.h"
#include "lib.rs.h" // generated by cxxbridge

void CreateExampleIVFIndex(rust::Str index_file_name) {
  std::cout << "Creating example IVF index in " << index_file_name << std::endl;
  const size_t VEC_DIM = 128;       // Vector dimension
  const size_t N_CLUSTERS = 100;    // Number of IVF clusters
  const size_t N_VECTORS = 100'000; // Number of vectors to index

  // Create index, default invert list implementation is memory
  faiss::IndexFlatL2 quantizer(VEC_DIM);
  faiss::IndexIVFFlat index(&quantizer, VEC_DIM, N_CLUSTERS);
  index.verbose = true;

  // Generate random vectors
  std::vector<float> xb(VEC_DIM * N_VECTORS);
  faiss::float_rand(xb.data(), VEC_DIM * N_VECTORS, 12345);

  index.train(N_VECTORS, xb.data());
  index.add(N_VECTORS, xb.data());

  // NOTE: rust::Str.data() does not have null terminator
  // https://cxx.rs/binding/str.html
  faiss::write_index(&index, std::string(index_file_name).c_str());
}

size_t GetClusterDataOffset(rust::Str index_file_name) {
  std::string file_path = std::string(index_file_name);

  // Use mmap since we don't really read the content of the inverted lists
  // TODO: We can also use the S3ReadNothingInvertedLists
  faiss::Index *index =
      faiss::read_index(file_path.c_str(), faiss::IO_FLAG_MMAP);
  faiss::IndexIVF *ivf_index = dynamic_cast<faiss::IndexIVF *>(index);
  if (ivf_index == nullptr) {
    throw std::runtime_error("Index is not IVF type for " + file_path);
  }

  // Calcuate the cluster data offset base on logic in write_index for the
  // default ArrayInvertedLists. When using IO_FLAG_MMAP the return type is
  // OnDiskInvertedLists (mmaped) via IOHook.
  // TODO: We may run into issue if the original inverted list is actually a
  // OnDiskInvertedLists...
  // TODO: ArrayInvertedListsPanorama is different from ArrayInvertedLists and
  // does not support IOHook.
  faiss::OnDiskInvertedLists *array_invlists =
      dynamic_cast<faiss::OnDiskInvertedLists *>(ivf_index->invlists);
  if (array_invlists == nullptr) {
    throw std::runtime_error(
        "Index inverted lists is not OnDiskInvertedLists type for " +
        file_path);
  }
  faiss::InvertedLists *invlists = ivf_index->invlists;
  size_t nlist = invlists->nlist;
  size_t code_size =
      invlists->code_size; // size of vector or quantized code in bytes

  // Cluster data is at the end of the file, so we use total file size minus
  // the size of all inverted lists data to get the offset.
  size_t cluster_data_size = 0;
  for (size_t list_no = 0; list_no < nlist; list_no++) {
    size_t list_size = invlists->list_size(list_no);
    // sizeof(idx_t) = 8 bytes
    cluster_data_size += list_size * (8 + code_size);
  }

  struct stat st;
  if (stat(file_path.c_str(), &st) != 0) {
    throw std::runtime_error("Cannot get file size for " + file_path);
  }
  size_t total_file_size = st.st_size;

  return total_file_size - cluster_data_size;
}