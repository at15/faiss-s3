#include <iostream>
#include <string>
#include <sys/stat.h>

#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFFlat.h>
#include <faiss/impl/FaissAssert.h>
#include <faiss/index_io.h>
#include <faiss/invlists/InvertedListsIOHook.h>
#include <faiss/invlists/OnDiskInvertedLists.h>
#include <faiss/utils/random.h>

#include "faiss_s3.h"
#include "s3_inverted_lists.h"
#include "lib.rs.h" // generated by cxxbridge

void CreateExampleIVFIndex(rust::Str index_file_name) {
  std::cout << "Creating example IVF index in " << index_file_name << std::endl;
  const size_t VEC_DIM = 128;       // Vector dimension
  const size_t N_CLUSTERS = 100;    // Number of IVF clusters
  const size_t N_VECTORS = 100'000; // Number of vectors to index

  // Create index, default invert list implementation is memory
  faiss::IndexFlatL2 quantizer(VEC_DIM);
  faiss::IndexIVFFlat index(&quantizer, VEC_DIM, N_CLUSTERS);
  index.verbose = true;

  // Generate random vectors
  std::vector<float> xb(VEC_DIM * N_VECTORS);
  faiss::float_rand(xb.data(), VEC_DIM * N_VECTORS, 12345);

  index.train(N_VECTORS, xb.data());
  index.add(N_VECTORS, xb.data());

  // NOTE: rust::Str.data() does not have null terminator
  // https://cxx.rs/binding/str.html
  faiss::write_index(&index, std::string(index_file_name).c_str());
}

size_t GetClusterDataOffset(rust::Str index_file_name) {
  std::string file_path = std::string(index_file_name);

  // Use IO_FLAG_S3 because we do not the actual cluster data.
  faiss_s3::RegisterS3ReadNothingIOHook();
  faiss::Index *index =
      faiss::read_index(file_path.c_str(), faiss_s3::IO_FLAG_S3);
  faiss::IndexIVF *ivf_index = dynamic_cast<faiss::IndexIVF *>(index);
  if (ivf_index == nullptr) {
    throw std::runtime_error("Index is not IVF type for " + file_path);
  }

  // Calcuate the cluster data offset base on logic in write_index for the
  // default ArrayInvertedLists. When using IO_FLAG_S3 the return type is
  // S3ReadNothingInvertedLists via IOHook.
  // TODO: We may run into issue for OnDiskInvertedLists, not tested
  // TODO: ArrayInvertedListsPanorama is different from ArrayInvertedLists and
  // does not support IOHook.
  faiss_s3::S3ReadNothingInvertedLists *read_nothing_invlists =
      dynamic_cast<faiss_s3::S3ReadNothingInvertedLists *>(ivf_index->invlists);
  if (read_nothing_invlists == nullptr) {
    throw std::runtime_error(
        "Index inverted lists is not S3ReadNothingInvertedLists for " +
        file_path);
  }
  // size of vector or quantized code in bytes
  size_t code_size =
      read_nothing_invlists->code_size;

  // Cluster data is at the end of the file, so we use total file size minus
  // the size of all inverted lists data to get the offset.
  size_t cluster_data_size = 0;
  for (size_t list_size : read_nothing_invlists->cluster_sizes) {
    cluster_data_size += list_size * (sizeof(faiss::idx_t) + code_size);
  }

  // TODO: We should be using std::filesystem but somehow claude code said it is not working
  struct stat st;
  if (stat(file_path.c_str(), &st) != 0) {
    throw std::runtime_error("Cannot get file size for " + file_path);
  }
  size_t total_file_size = st.st_size;

  return total_file_size - cluster_data_size;
}