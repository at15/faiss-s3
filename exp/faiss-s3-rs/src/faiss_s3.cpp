#include <iostream>
#include <string>
#include <sys/stat.h>

#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFFlat.h>
#include <faiss/impl/FaissAssert.h>
#include <faiss/index_io.h>
#include <faiss/invlists/InvertedListsIOHook.h>
#include <faiss/invlists/OnDiskInvertedLists.h>
#include <faiss/utils/random.h>
#include <faiss/utils/utils.h>

#include "faiss_s3.h"
#include "lib.rs.h" // generated by cxxbridge
#include "s3_inverted_lists.h"

void CreateExampleIVFIndex(rust::Str index_file_name) {
  std::cout << "Creating example IVF index in " << index_file_name << std::endl;
  const size_t VEC_DIM = 128;       // Vector dimension
  const size_t N_CLUSTERS = 100;    // Number of IVF clusters
  const size_t N_VECTORS = 100'000; // Number of vectors to index

  // Create index, default invert list implementation is memory
  faiss::IndexFlatL2 quantizer(VEC_DIM);
  faiss::IndexIVFFlat index(&quantizer, VEC_DIM, N_CLUSTERS);
  index.verbose = true;

  // Generate random vectors
  std::vector<float> xb(VEC_DIM * N_VECTORS);
  faiss::float_rand(xb.data(), VEC_DIM * N_VECTORS, 12345);

  index.train(N_VECTORS, xb.data());
  index.add(N_VECTORS, xb.data());

  // NOTE: rust::Str.data() does not have null terminator
  // https://cxx.rs/binding/str.html
  faiss::write_index(&index, std::string(index_file_name).c_str());
}

void SearchExampleIVFIndex(rust::Str index_file_name) {
  using idx_t = faiss::idx_t;

  std::string file_path = std::string(index_file_name);
  // Use MMAP because we are just testing calling search_preassigned
  faiss::Index *index =
      faiss::read_index(file_path.c_str(), faiss::IO_FLAG_MMAP);
  faiss::IndexIVF *ivf_index = dynamic_cast<faiss::IndexIVF *>(index);
  if (ivf_index == nullptr) {
    throw std::runtime_error("Index is not IVF type for " + file_path);
  }

  // TODO: Only one query for now. Base on index->parallel_mode
  // the official implementation may parallel over queries/invlists
  const idx_t n = 1;
  // Create a random query
  std::vector<float> x(ivf_index->d * n);
  faiss::float_rand(x.data(), ivf_index->d * n, 12345);
  const size_t nprobe = 2;
  ivf_index->verbose = true;

  // Copy from IndexIVF::search() in deps/faiss-home/include/faiss/IndexIVF.h
  // ivf_index->search()
  std::unique_ptr<idx_t[]> idx(new idx_t[n * nprobe]);
  std::unique_ptr<float[]> coarse_dis(new float[n * nprobe]);

  // 1. Search the quantizer to the clusters
  double t0 = faiss::getmillisecs();
  ivf_index->quantizer->search(n, x.data(), nprobe, coarse_dis.get(), idx.get(),
                               nullptr); // TODO: pass params->quantizer_params
  double t1 = faiss::getmillisecs();
  // TODO: In faiss code, it will call the prefetch_lists() to prefetch the clusters.
  // In our rust code, we can fetch the clusters in parallel using async io and
  // block until all of them are fetched/error out

  // TODO: hard coded to top 5
  const idx_t k = 5;
  std::vector<float> distances(k);
  std::vector<faiss::idx_t> labels(k);

  // 2. Search matched clusters to get top k across all matched clusters
  faiss::IndexIVFStats ivf_stats;
  const faiss::IVFSearchParameters *params = nullptr;
  ivf_index->search_preassigned(
      n, x.data(), k, idx.get(), coarse_dis.get(),
      distances.data(), // NOTE: Passing raw pointer fine because there is at
                        // most k results
      labels.data(), false, params, &ivf_stats);
  double t2 = faiss::getmillisecs();
  ivf_stats.quantization_time += t1 - t0;
  ivf_stats.search_time +=
      t2 - t0; // TODO: Use += because search_preassigned up the time as well?

  std::cout << "Search time: " << t2 - t0 << " ms" << std::endl;
  std::cout << "Quantization time: " << t1 - t0 << " ms" << std::endl;
}

size_t GetClusterDataOffset(rust::Str index_file_name) {
  std::string file_path = std::string(index_file_name);

  // Use IO_FLAG_S3 because we do not the actual cluster data.
  faiss_s3::RegisterS3ReadNothingIOHook();
  faiss::Index *index =
      faiss::read_index(file_path.c_str(), faiss_s3::IO_FLAG_S3);
  faiss::IndexIVF *ivf_index = dynamic_cast<faiss::IndexIVF *>(index);
  if (ivf_index == nullptr) {
    throw std::runtime_error("Index is not IVF type for " + file_path);
  }

  // Calcuate the cluster data offset base on logic in write_index for the
  // default ArrayInvertedLists. When using IO_FLAG_S3 the return type is
  // S3ReadNothingInvertedLists via IOHook.
  // TODO: We may run into issue for OnDiskInvertedLists, not tested
  // TODO: ArrayInvertedListsPanorama is different from ArrayInvertedLists and
  // does not support IOHook.
  faiss_s3::S3ReadNothingInvertedLists *read_nothing_invlists =
      dynamic_cast<faiss_s3::S3ReadNothingInvertedLists *>(ivf_index->invlists);
  if (read_nothing_invlists == nullptr) {
    throw std::runtime_error(
        "Index inverted lists is not S3ReadNothingInvertedLists for " +
        file_path);
  }
  // size of vector or quantized code in bytes
  size_t code_size = read_nothing_invlists->code_size;

  // Cluster data is at the end of the file, so we use total file size minus
  // the size of all inverted lists data to get the offset.
  size_t cluster_data_size = 0;
  for (size_t list_size : read_nothing_invlists->cluster_sizes) {
    cluster_data_size += list_size * (sizeof(faiss::idx_t) + code_size);
  }

  // TODO: We should be using std::filesystem but somehow claude code said it is
  // not working
  struct stat st;
  if (stat(file_path.c_str(), &st) != 0) {
    throw std::runtime_error("Cannot get file size for " + file_path);
  }
  size_t total_file_size = st.st_size;

  return total_file_size - cluster_data_size;
}

FaissIVFIndexS3::FaissIVFIndexS3(std::unique_ptr<faiss::IndexIVF> _index)
    : index(std::move(_index)) {}

std::unique_ptr<FaissIVFIndexS3>
CreateFaissIVFIndexS3(rust::Vec<uint8_t> index_without_cluster_data) {
  faiss::VectorIOReader reader;
  reader.data = std::vector<uint8_t>(index_without_cluster_data.begin(),
                                     index_without_cluster_data.end());

  faiss_s3::RegisterS3ReadNothingIOHook();
  faiss::Index *index = faiss::read_index(&reader, faiss_s3::IO_FLAG_S3);
  faiss::IndexIVF *ivf_index = dynamic_cast<faiss::IndexIVF *>(index);
  if (ivf_index == nullptr) {
    delete index; // Clean up if cast fails
    throw std::runtime_error("Index is not IVF type");
  }

  return std::make_unique<FaissIVFIndexS3>(
      std::unique_ptr<faiss::IndexIVF>(ivf_index));
}